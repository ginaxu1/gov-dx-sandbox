# This config tells Apollo Router how to behave, including
# how to integrate with the external Go policy governance service 
environments:
  dev: # Defines a development environment for the Router, can be prod, staging, etc.
    supergraph: ./supergraph.yaml 

    # --- External Authorization Configuration ---
    # This section configures the Router to make an HTTP call to the Go policy service
    # for authorization decisions before executing the GraphQL operation
    authorization:
      - name: policy-governance-service
        # Define the external HTTP service details
        external:
          # The URL of the Go policy governance service endpoint
          # This MUST match where the main.go registers HandlePolicyRequest
          url: "http://localhost:8081/evaluate-policy"
          method: POST
          headers:
            - name: Content-Type
              value: application/json
            # Forward the 'x-consumer-id' header from the client to the Go service
            - name: x-consumer-id
              value: "{context.x-consumer-id}"
            # Uncomment and configure if we need to forward Authorization tokens
            # - name: Authorization
            #   value: "{context.Authorization}"

          # CRITICAL: Tells the Router to send the full incoming GraphQL request body
          # to the external policy service. Policy Governance Go service will parse this.
          request:
            send_graphql_request_body: true

          # --- How to interpret the response from the Go policy service ---
          # This section tells the Router what to do based on the JSON response from the service
          response:
            for_each: accessScopes
            with: scope # 'scope' is a variable representing the current item in the loop
            do:
              # If any field's resolvedClassification is "DENY", the Router will
              # immediately deny the entire GraphQL request.
              # This acts as the primary gatekeeper for explicitly denied fields.
              if "{{ .scope.resolvedClassification }}" == "DENY":
                deny_request:
                  # Customize the error message that the client receives
                  message: "Access denied to field '{{ .scope.subgraphName }}.{{ .scope.typeName }}.{{ .scope.fieldName }}' by policy."
                  # Add extensions for client-side error handling
                  extensions:
                    code: "ACCESS_DENIED_BY_POLICY"
                    deniedField: "{{ .scope.subgraphName }}.{{ .scope.typeName }}.{{ .scope.fieldName }}"

              # If any field's resolvedClassification requires consent, the Router
              # will NOT block the request at this stage. The request will proceed.
              # Consent handling is deferred for future implementation in subgraphs or a Consent Engine.
              if "{{ .scope.resolvedClassification }}" == "ALLOW_PROVIDER_CONSENT" or "{{ .scope.resolvedClassification }}" == "ALLOW_CITIZEN_CONSENT" or "{{ .scope.resolvedClassification }}" == "ALLOW_CONSENT":
                # Log a message, but do not deny the request here.
                # This information will be available in the context for subgraphs.
                log: "info"
                message: "Policy Governance: Field '{{ .scope.subgraphName }}.{{ .scope.typeName }}.{{ .scope.fieldName }}' requires consent ({{ .scope.resolvedClassification }}). Request proceeding."

