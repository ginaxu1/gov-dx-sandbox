package services

import (
	"context"
	"fmt"
	"log/slog"
	"time"

	"github.com/gov-dx-sandbox/audit-service/models"
	"gorm.io/gorm"
)

// AuditService provides access to audit logs using GORM
type AuditService struct {
	db *gorm.DB
}

// NewAuditService creates a new GORM-based audit service
func NewAuditService(db *gorm.DB) *AuditService {
	return &AuditService{db: db}
}

// CreateLog creates a new log entry using GORM
func (s *AuditService) CreateLog(ctx context.Context, logReq *models.LogRequest) (*models.Log, error) {
	// Set default values for new fields
	requestType := logReq.RequestType
	if requestType == "" {
		requestType = "unknown"
	}

	authMethod := logReq.AuthMethod
	if authMethod == "" {
		authMethod = "none"
	}

	// Create audit log entry
	// JSONString type handles JSON encoding automatically
	var responseData *models.JSONString
	auditLog := &models.AuditLog{
		EventID:           "", // Will be auto-generated by BeforeCreate hook
		Timestamp:         time.Now(),
		ConsumerID:        logReq.ApplicationID, // Map application_id to consumer_id
		ProviderID:        logReq.SchemaID,      // Map schema_id to provider_id
		RequestedData:     models.JSONString(logReq.RequestedData),
		ResponseData:      responseData, // Default to nil
		TransactionStatus: logReq.Status,
		CitizenHash:       "unknown", // Default value
		UserAgent:         "unknown", // Default value
		IPAddress:         nil,       // Default to nil
		ApplicationID:     logReq.ApplicationID,
		SchemaID:          logReq.SchemaID,
		Status:            logReq.Status,
		// New fields for M2M vs User differentiation
		RequestType: requestType,
		AuthMethod:  authMethod,
		UserID:      &logReq.UserID,
		SessionID:   &logReq.SessionID,
	}

	// Save to database
	if err := s.db.WithContext(ctx).Create(auditLog).Error; err != nil {
		slog.Error("Failed to create audit log", "error", err)
		return nil, fmt.Errorf("failed to create audit log: %w", err)
	}

	// Convert to response model
	log := &models.Log{
		ID:            auditLog.ID,
		Timestamp:     auditLog.Timestamp,
		Status:        auditLog.Status,
		RequestedData: string(auditLog.RequestedData),
		ApplicationID: auditLog.ApplicationID,
		SchemaID:      auditLog.SchemaID,
		ConsumerID:    auditLog.ConsumerID,
		ProviderID:    auditLog.ProviderID,
		CreatedAt:     auditLog.CreatedAt,
	}

	return log, nil
}

// GetAuditLogs retrieves audit logs with pagination using GORM
func (s *AuditService) GetAuditLogs(ctx context.Context, limit, offset int) ([]models.Log, int64, error) {
	var auditLogs []models.AuditLog
	var total int64

	// Get total count
	if err := s.db.WithContext(ctx).Model(&models.AuditLog{}).Count(&total).Error; err != nil {
		return nil, 0, fmt.Errorf("failed to count audit logs: %w", err)
	}

	// Get paginated results
	if err := s.db.WithContext(ctx).
		Order("created_at DESC").
		Limit(limit).
		Offset(offset).
		Find(&auditLogs).Error; err != nil {
		return nil, 0, fmt.Errorf("failed to get audit logs: %w", err)
	}

	// Convert to response models
	logs := make([]models.Log, len(auditLogs))
	for i, auditLog := range auditLogs {
		logs[i] = models.Log{
			ID:            auditLog.ID,
			Timestamp:     auditLog.Timestamp,
			Status:        auditLog.Status,
			RequestedData: string(auditLog.RequestedData),
			ApplicationID: auditLog.ApplicationID,
			SchemaID:      auditLog.SchemaID,
			ConsumerID:    auditLog.ConsumerID,
			ProviderID:    auditLog.ProviderID,
			CreatedAt:     auditLog.CreatedAt,
		}
	}

	return logs, total, nil
}

// GetAuditLogsByApplicationID retrieves audit logs for a specific application
func (s *AuditService) GetAuditLogsByApplicationID(ctx context.Context, applicationID string, limit, offset int) ([]models.Log, int64, error) {
	var auditLogs []models.AuditLog
	var total int64

	// Get total count for application
	if err := s.db.WithContext(ctx).Model(&models.AuditLog{}).
		Where("application_id = ?", applicationID).
		Count(&total).Error; err != nil {
		return nil, 0, fmt.Errorf("failed to count audit logs for application: %w", err)
	}

	// Get paginated results for application
	if err := s.db.WithContext(ctx).
		Where("application_id = ?", applicationID).
		Order("created_at DESC").
		Limit(limit).
		Offset(offset).
		Find(&auditLogs).Error; err != nil {
		return nil, 0, fmt.Errorf("failed to get audit logs for application: %w", err)
	}

	// Convert to response models
	logs := make([]models.Log, len(auditLogs))
	for i, auditLog := range auditLogs {
		logs[i] = models.Log{
			ID:            auditLog.ID,
			Timestamp:     auditLog.Timestamp,
			Status:        auditLog.Status,
			RequestedData: string(auditLog.RequestedData),
			ApplicationID: auditLog.ApplicationID,
			SchemaID:      auditLog.SchemaID,
			ConsumerID:    auditLog.ConsumerID,
			ProviderID:    auditLog.ProviderID,
			CreatedAt:     auditLog.CreatedAt,
		}
	}

	return logs, total, nil
}

// GetAuditLogsBySchemaID retrieves audit logs for a specific schema
func (s *AuditService) GetAuditLogsBySchemaID(ctx context.Context, schemaID string, limit, offset int) ([]models.Log, int64, error) {
	var auditLogs []models.AuditLog
	var total int64

	// Get total count for schema
	if err := s.db.WithContext(ctx).Model(&models.AuditLog{}).
		Where("schema_id = ?", schemaID).
		Count(&total).Error; err != nil {
		return nil, 0, fmt.Errorf("failed to count audit logs for schema: %w", err)
	}

	// Get paginated results for schema
	if err := s.db.WithContext(ctx).
		Where("schema_id = ?", schemaID).
		Order("created_at DESC").
		Limit(limit).
		Offset(offset).
		Find(&auditLogs).Error; err != nil {
		return nil, 0, fmt.Errorf("failed to get audit logs for schema: %w", err)
	}

	// Convert to response models
	logs := make([]models.Log, len(auditLogs))
	for i, auditLog := range auditLogs {
		logs[i] = models.Log{
			ID:            auditLog.ID,
			Timestamp:     auditLog.Timestamp,
			Status:        auditLog.Status,
			RequestedData: string(auditLog.RequestedData),
			ApplicationID: auditLog.ApplicationID,
			SchemaID:      auditLog.SchemaID,
			ConsumerID:    auditLog.ConsumerID,
			ProviderID:    auditLog.ProviderID,
			CreatedAt:     auditLog.CreatedAt,
		}
	}

	return logs, total, nil
}

// GetAuditLogByID retrieves a specific audit log by ID
func (s *AuditService) GetAuditLogByID(ctx context.Context, id string) (*models.Log, error) {
	var auditLog models.AuditLog

	if err := s.db.WithContext(ctx).First(&auditLog, "id = ?", id).Error; err != nil {
		if err == gorm.ErrRecordNotFound {
			return nil, fmt.Errorf("audit log not found")
		}
		return nil, fmt.Errorf("failed to get audit log: %w", err)
	}

	// Convert to response model
	log := &models.Log{
		ID:            auditLog.ID,
		Timestamp:     auditLog.Timestamp,
		Status:        auditLog.Status,
		RequestedData: string(auditLog.RequestedData),
		ApplicationID: auditLog.ApplicationID,
		SchemaID:      auditLog.SchemaID,
		ConsumerID:    auditLog.ConsumerID,
		ProviderID:    auditLog.ProviderID,
		CreatedAt:     auditLog.CreatedAt,
	}

	return log, nil
}
